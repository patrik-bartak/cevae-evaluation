import os
import time
import traceback

import pandas as pd

from graphing.grapher import Grapher
from utils import select_features, select_proxies
from typing import *
import torch


class CevaeGenerator:
    """
        A class used to generate data based on some underlying functions.
        All data is generated into a directory 'sample/data/data_dump_{name or hash value of the class}'.
        The data is saved as a pandas table, along the data some figures are stored to represent the coverage over
        the first two features of the treatment effect.
        ...

        Attributes
        ----------
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature.
        directory: str
            directory where all these data dumps are stored. By default is set to 'sample/data'
        generated_files: Dict[str, List[str]]
            dictionary of files and graphs generated by this class

        Methods
        -------
        generate_data(number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False)
            generates a table with data based on input functions of the class
        generate_row()
            generates one row of the data table
        generate_feature(index):
            generates the value for a feature based on self.distributions
        create_graphs(df):
            generates all graphs based on the input dataframe
        create_coverage_graph(df):
            generates a coverage graph based on the input dataframe
        save_graphs():
            saves all generated graphs as figures
        save_data(df):
            saves the dataframe as a csv file
        """

    def __init__(self,
                 distributions, proxy_function,
                 treatment_function, outcome_function,
                 dimensions: int,
                 name: str = None):
        assert len(distributions) == 1 or len(distributions) == dimensions, f"Actual dist: {len(distributions)}; Actual dim: {dimensions}"
        if name is None:
            name = self.__hash__()
        self.dimensions = dimensions
        self.distributions = distributions
        self.proxy_function = proxy_function
        self.treatment_function = treatment_function
        self.outcome_function = outcome_function
        self.directory: str = f'data/data_dump_{name}'
        os.makedirs(self.directory, exist_ok=True)
        self.generated_files: Dict[str, List[str]] = {'data': [], 'graphs': []}

    def generate_data(self, number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False):
        """
        Parameters
        ----------
        number_of_samples : int
            indicates the number of rows to be generated
        save_data: bool
            indicates whether the generated data should be stored
        show_graphs: bool
            indicates whether the generated graphs should also be shown WIP
        save_graphs: bool
            indicates whether the generated graphs should be stored
        """
        torch.set_default_tensor_type(torch.FloatTensor)
        features, proxies, treatment, outcome, treatment_effect, y_1, y_0 = self.generate_all()
        assert len(features) == self.dimensions
        columns = [f'feature_{i}' for i in range(self.dimensions)]
        proxy_columns = [[f'proxy_{j}_for_feature_{i}' for j in range(len(proxies[i]))] for i in range(len(proxies))]
        proxy_flat_cols = [item for sublist in proxy_columns for item in sublist]
        features = torch.concat(features, dim=1)
        proxy_flat = [item for sublist in proxies for item in sublist]
        proxy_flat = torch.concat(proxy_flat, dim=1)
        print(features.size(), proxy_flat.size(), treatment.size(), outcome.size(), treatment_effect.size(), y_1.size(), y_0.size())
        empty = torch.zeros([number_of_samples, 1])
        entire_dataset = torch.concat([features, proxy_flat, treatment, outcome, empty,
                                       treatment_effect, empty, y_1, y_0, empty, treatment_effect], dim=1)
        torch.set_default_tensor_type(torch.cuda.FloatTensor)
        # assert len(features) == len(proxy_columns), f"Expected {len(features)} columns but found {len(proxy_columns)}"
        columns.extend(proxy_flat_cols)
        columns.append('treatment')
        columns.append('outcome')
        columns.append('main_effect')
        columns.append('treatment_effect')
        columns.append('propensity')
        columns.append('y0')
        columns.append('y1')
        columns.append('noise')
        columns.append('cate')
        df = pd.DataFrame(data=entire_dataset, columns=columns)
        if save_data:
            self.save_data(df)
        if show_graphs or save_graphs:
            self.create_graphs(df, show_graphs, save_graphs)
        return select_features(df), select_proxies(df), df['treatment'], df['outcome'], df['treatment_effect']

    def generate_all(self):
        """
        Generator row of data
        :return: Row of data
        """
        features = []
        for dimension in range(self.dimensions):
            features.append(self.generate_feature(dimension))
        # 2D array of proxies
        # First dimension has an entry for each feature
        # Second dimension has an entry for each proxy for a given feature
        proxies = self.proxy_function(features)
        # propensity = p(T = 1 | X)
        treatment = self.treatment_function(features)
        outcome = self.outcome_function(features, treatment)
        # Find true ITE using monte carlo sampling
        y_0 = self.outcome_function(features, 0, mean=True)
        y_1 = self.outcome_function(features, 1, mean=True)
        treatment_effect = y_1 - y_0
        # True treatment effect is y1 - y0 where there is no noise
        return features, proxies, treatment, outcome, treatment_effect, y_1, y_0

    def generate_feature(self, index):
        """
        Generate one distribution feature
        :param index: Index of feature to generate
        :return:
        """
        if len(self.distributions) == 1:
            return self.distributions[0]()
        return self.distributions[index]()

    def create_graphs(self, df, show_graphs, save_graphs):
        """
        Create plots
        :param df: Data to use in plots
        :param show_graphs: Whether to show the plots
        :param save_graphs: Whether to save the plots
        :return:
        """
        try:
            grapher = Grapher(self.directory, show_graphs, save_graphs)

            fn = f'/ground_truth_feat0'
            grapher.scatter_2d(fn, df['feature_0'], df['treatment_effect'],
                               "Feature 0", "Treatment Effect")
            fn = f'/observed_p0f0'
            grapher.scatter_2d(fn, df['proxy_0_for_feature_0'], df['treatment_effect'],
                               "Proxy 0 for feature 0", "Treatment Effect")
            fn = f'/kde_p0f0'
            grapher.kde(fn, df['proxy_0_for_feature_0'])
            fn = f'/kde_f0'
            grapher.kde(fn, df['feature_0'])
            fn = f'/ground_truth_feat1'
            grapher.scatter_2d(fn, df['feature_1'], df['treatment_effect'],
                               "Feature 1", "Treatment Effect")
            fn = f'/ground_truth_feat2'
            grapher.scatter_2d(fn, df['feature_2'], df['treatment_effect'],
                               "Feature 2", "Treatment Effect")
            fn = f'/ground_truth_2d_feat01'
            grapher.scatter_2d_color(fn, df['feature_0'], df['feature_1'], df['treatment_effect'],
                                     "Feature 0", "Feature 1", "Treatment Effect Strength")
        except Exception:
            print(traceback.format_exc())

    def save_data(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        os.makedirs(self.directory, exist_ok=True)
        filename = f'/generated_data{time.ctime()}.csv'.replace(' ', '_').replace(':', '-')
        self.generated_files['data'].append(filename)
        df.to_csv(self.directory + filename)
