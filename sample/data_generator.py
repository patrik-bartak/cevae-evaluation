import os
import time
import traceback

import numpy as np
import pandas as pd
import torch
import pyro.distributions as dist
import matplotlib.pyplot as plt

from sample.grapher import Grapher
from utils import select_features, select_proxies
from typing import *


class ProxyGenerator:
    """
        A class used to generate data based on some underlying functions.
        All data is generated into a directory 'sample/data/data_dump_{name or hash value of the class}'.
        The data is saved as a pandas table, along the data some figures are stored to represent the coverage over
        the first two features of the treatment effect.
        ...

        Attributes
        ----------
        main_effect : Callable[[List[float]], float]
            a lambda function defining the effect of features X on outcome Y
        treatment_effect : Callable[[List[float]], float]
            a lambda function defining the effect of treatment W on outcome Y
        treatment_propensity : Callable[[List[float]], float]
            a lambda function defining the effect of features X on treatment W
        noise : Callable[[], float]
            a lambda function defining the noise distribution
        cate : Callable[[List[float]], float]
            a lambda function defining the conditional averaged treatment effect (CATE) of a subpopulation defined
            by a feature vector. To compute only averaged treatment effect (ATE) keep the return value constant.
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature.
        directory: str
            directory where all these data dumps are stored. By default is set to 'sample/data'
        generated_files: Dict[str, List[str]]
            dictionary of files and graphs generated by this class

        Methods
        -------
        generate_data(number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False)
            generates a table with data based on input functions of the class
        generate_row()
            generates one row of the data table
        generate_feature(index):
            generates the value for a feature based on self.distributions
        create_graphs(df):
            generates all graphs based on the input dataframe
        create_coverage_graph(df):
            generates a coverage graph based on the input dataframe
        save_graphs():
            saves all generated graphs as figures
        save_data(df):
            saves the dataframe as a csv file
        """

    def __init__(self,
                 main_effect: Callable[[List[float]], float],
                 treatment_effect: Callable[[List[float]], float],
                 treatment_propensity: Callable[[List[float]], float],
                 proxy_function: Callable[[List[float]], List[List[float]]],
                 noise: Callable[[], float],
                 cate: Callable[[List[float]], float],
                 treatment_function: Callable[[float, float], float],
                 outcome_function: Callable[[float, float, float, float], float],
                 dimensions: int,
                 distributions: List[Callable[[], float]],
                 name: str = None):
        """
        Parameters
        ----------
        main_effect : Callable[[List[float]], float]
            a lambda function defining the effect of features X on outcome Y
        treatment_effect : Callable[[List[float]], float]
            a lambda function defining the effect of treatment W on outcome Y
        treatment_propensity : Callable[[List[float]], float]
            a lambda function defining the effect of features X on treatment W
        noise : Callable[[], float]
            a lambda function defining the noise distribution
        cate : Callable[[List[float]], float]
            a lambda function defining the conditional averaged treatment effect (CATE) of a subpopulation defined
            by a feature vector. To compute only averaged treatment effect (ATE) keep the return value constant.
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature
        name: str
            name of the data dump. This will be used to create the directory of the data dump
        """
        # Either have 1 distribution applied on all features, or have a specific distribution per feature
        assert len(distributions) == 1 or len(distributions) == dimensions
        if name is None:
            name = self.__hash__()
        self.main_effect = main_effect
        self.treatment_effect = treatment_effect
        self.treatment_propensity = treatment_propensity
        self.treatment_function = treatment_function
        self.proxy_function = proxy_function
        self.outcome_function = outcome_function
        self.noise = noise
        self.cate = cate
        self.dimensions = dimensions
        self.distributions = distributions
        self.directory: str = f'data/data_dump_{name}'
        os.makedirs(self.directory, exist_ok=True)
        self.generated_files: Dict[str, List[str]] = {'data': [], 'graphs': []}

    def generate_data(self, number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False):
        """
        Parameters
        ----------
        number_of_samples : int
            indicates the number of rows to be generated
        save_data: bool
            indicates whether the generated data should be stored
        show_graphs: bool
            indicates whether the generated graphs should also be shown WIP
        save_graphs: bool
            indicates whether the generated graphs should be stored
        """
        features, proxies, treatment, outcome, main_effect, treatment_effect, propensity, y0, y1, noise, cate = self.generate_row()
        assert len(features) == self.dimensions
        columns = [f'feature_{i}' for i in range(self.dimensions)]
        proxy_columns = [[f'proxy_{j}_for_feature_{i}' for j in range(len(proxies[i]))] for i in range(len(proxies))]
        assert len(features) == len(proxy_columns)
        proxy_flat = [item for sublist in proxy_columns for item in sublist]
        columns.extend(proxy_flat)
        columns.append('treatment')
        columns.append('outcome')
        columns.append('main_effect')
        columns.append('treatment_effect')
        columns.append('propensity')
        columns.append('y0')
        columns.append('y1')
        columns.append('noise')
        columns.append('cate')
        df = pd.DataFrame([], columns=columns)
        for i in range(number_of_samples):
            features, proxies, treatment, outcome, main_effect, treatment_effect, propensity, y0, y1, noise, cate = self.generate_row()
            proxy_flat = [item for sublist in proxies for item in sublist]
            features.extend(proxy_flat)
            features.append(treatment)
            features.append(outcome)
            features.append(main_effect)
            features.append(treatment_effect)
            features.append(propensity)
            features.append(y0)
            features.append(y1)
            features.append(noise)
            features.append(cate)
            df.loc[len(df.index)] = features
        if save_data:
            self.save_data(df)
        if show_graphs or save_graphs:
            self.create_graphs(df, show_graphs, save_graphs)
        return select_features(df), select_proxies(df), df['treatment'], df['outcome'], df['main_effect'], \
               df['treatment_effect'], df['propensity'], df['y0'], df['y1'], df['noise'], df['cate']

    def generate_row(self):
        features = []
        for dimension in range(self.dimensions):
            features.append(self.generate_feature(dimension))
        # 2D array of proxies
        # First dimension has an entry for each feature
        # Second dimension has an entry for each proxy for a given feature
        proxies = self.proxy_function(features)
        # propensity = p(T = 1 | X)
        propensity = self.treatment_propensity(features)
        treatment_noise = self.noise()
        treatment = self.treatment_function(propensity, treatment_noise)
        treatment_effect = self.treatment_effect(features)
        main_effect = self.main_effect(features)
        noise = self.noise()
        outcome = self.outcome_function(main_effect, treatment, treatment_effect, noise)
        y0 = self.outcome_function(main_effect, 0, treatment_effect, 0)
        y1 = self.outcome_function(main_effect, 1, treatment_effect, 0)
        # Cate : E[Y1 - Y0|X]
        cate = self.cate(features)
        # True treatment effect is y1 - y0 where there is no noise
        return features, proxies, treatment, outcome, main_effect, y1 - y0, propensity, y0, y1, noise, cate

    def generate_feature(self, index):
        """
        Parameters
        ----------
        index : int
            represent the index from which distribution should the feature take its value from.
            If only one distribution is provided all features will take from that distribution.
        """
        if len(self.distributions) == 1:
            return self.distributions[0]()
        return self.distributions[index]()

    def create_graphs(self, df, show_graphs, save_graphs):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        grapher = Grapher(self.directory, show_graphs, save_graphs)

        fn = f'/ground_truth_feat0'
        grapher.scatter_2d(fn, df['feature_0'], df['treatment_effect'],
                           "Feature 0", "Treatment Effect")
        fn = f'/ground_truth_feat1'
        grapher.scatter_2d(fn, df['feature_1'], df['treatment_effect'],
                           "Feature 1", "Treatment Effect")
        fn = f'/ground_truth_feat2'
        grapher.scatter_2d(fn, df['feature_2'], df['treatment_effect'],
                           "Feature 2", "Treatment Effect")
        fn = f'/ground_truth_2d_feat01'
        grapher.scatter_2d_color(fn, df['feature_0'], df['feature_1'], df['treatment_effect'],
                                 "Feature 0", "Feature 1", "Treatment Effect Strength")

    def save_data(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        os.makedirs(self.directory, exist_ok=True)
        filename = f'/generated_data{time.ctime()}.csv'.replace(' ', '_').replace(':', '-')
        self.generated_files['data'].append(filename)
        df.to_csv(self.directory + filename)


class CevaeGenerator:
    """
        A class used to generate data based on some underlying functions.
        All data is generated into a directory 'sample/data/data_dump_{name or hash value of the class}'.
        The data is saved as a pandas table, along the data some figures are stored to represent the coverage over
        the first two features of the treatment effect.
        ...

        Attributes
        ----------
        main_effect : Callable[[List[float]], float]
            a lambda function defining the effect of features X on outcome Y
        treatment_effect : Callable[[List[float]], float]
            a lambda function defining the effect of treatment W on outcome Y
        treatment_propensity : Callable[[List[float]], float]
            a lambda function defining the effect of features X on treatment W
        noise : Callable[[], float]
            a lambda function defining the noise distribution
        cate : Callable[[List[float]], float]
            a lambda function defining the conditional averaged treatment effect (CATE) of a subpopulation defined
            by a feature vector. To compute only averaged treatment effect (ATE) keep the return value constant.
        treatment_function : Callable[[float, float], float]
            a lambda function defining how it is determined whether treatment is given or not. The inputs should be
            propensity and noise. Usually the function should be Ber(propensity) but it can be changed
        outcome_function : Callable[[float, float, float, float], float]
            a lambda function defining how the outcome is computed. The inputs are the results of
            main_effect, treatment, treatment_effect, noise
        dimensions: int
            integer representing the number of features to be generated
        distributions: List[Callable[[], float]]
            list of functions that determine the values of features. If only one function is given it will be used
            for all features, if multiple are used they need to be defined for every feature.
        directory: str
            directory where all these data dumps are stored. By default is set to 'sample/data'
        generated_files: Dict[str, List[str]]
            dictionary of files and graphs generated by this class

        Methods
        -------
        generate_data(number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False)
            generates a table with data based on input functions of the class
        generate_row()
            generates one row of the data table
        generate_feature(index):
            generates the value for a feature based on self.distributions
        create_graphs(df):
            generates all graphs based on the input dataframe
        create_coverage_graph(df):
            generates a coverage graph based on the input dataframe
        save_graphs():
            saves all generated graphs as figures
        save_data(df):
            saves the dataframe as a csv file
        """

    def __init__(self,
                 distributions, proxy_function,
                 treatment_function, outcome_function,
                 dimensions: int,
                 name: str = None):
        """
        Parameters
        """
        assert len(distributions) == 1 or len(distributions) == dimensions
        if name is None:
            name = self.__hash__()
        self.dimensions = dimensions
        self.distributions = distributions
        self.proxy_function = proxy_function
        self.treatment_function = treatment_function
        self.outcome_function = outcome_function
        self.directory: str = f'data/data_dump_{name}'
        os.makedirs(self.directory, exist_ok=True)
        self.generated_files: Dict[str, List[str]] = {'data': [], 'graphs': []}

    def generate_data(self, number_of_samples: int, save_data: bool = True, show_graphs: bool = False,
                      save_graphs: bool = False):
        """
        Parameters
        ----------
        number_of_samples : int
            indicates the number of rows to be generated
        save_data: bool
            indicates whether the generated data should be stored
        show_graphs: bool
            indicates whether the generated graphs should also be shown WIP
        save_graphs: bool
            indicates whether the generated graphs should be stored
        """
        features, proxies, treatment, outcome, treatment_effect, y_1, y_0 = self.generate_row()
        assert len(features) == self.dimensions
        columns = [f'feature_{i}' for i in range(self.dimensions)]
        proxy_columns = [[f'proxy_{j}_for_feature_{i}' for j in range(len(proxies[i]))] for i in range(len(proxies))]
        assert len(features) == len(proxy_columns), f"Expected {len(features)} columns but found {len(proxy_columns)}"
        proxy_flat = [item for sublist in proxy_columns for item in sublist]
        columns.extend(proxy_flat)
        columns.append('treatment')
        columns.append('outcome')
        columns.append('main_effect')
        columns.append('treatment_effect')
        columns.append('propensity')
        columns.append('y0')
        columns.append('y1')
        columns.append('noise')
        columns.append('cate')
        df = pd.DataFrame([], columns=columns)
        for i in range(number_of_samples):
            features, proxies, treatment, outcome, treatment_effect, y_1, y_0 = self.generate_row()
            proxy_flat = [item for sublist in proxies for item in sublist]
            features.extend(proxy_flat)
            features.append(treatment)
            features.append(outcome)
            features.append(0)
            features.append(treatment_effect)
            features.append(0)
            features.append(y_0)
            features.append(y_1)
            features.append(0)
            features.append(treatment_effect)
            df.loc[len(df.index)] = features
        if save_data:
            self.save_data(df)
        if show_graphs or save_graphs:
            self.create_graphs(df, show_graphs, save_graphs)
        return select_features(df), select_proxies(df), df['treatment'], df['outcome'], df['treatment_effect']

    def generate_row(self):
        features = []
        for dimension in range(self.dimensions):
            features.append(self.generate_feature(dimension))
        # 2D array of proxies
        # First dimension has an entry for each feature
        # Second dimension has an entry for each proxy for a given feature
        proxies = self.proxy_function(features)
        # propensity = p(T = 1 | X)
        treatment = self.treatment_function(features)
        outcome = self.outcome_function(features, treatment)
        # Find true ITE using monte carlo sampling
        y_0 = self.outcome_function(features, 0, mean=True)
        y_1 = self.outcome_function(features, 1, mean=True)
        treatment_effect = y_1 - y_0
        # True treatment effect is y1 - y0 where there is no noise
        return features, proxies, treatment, outcome, treatment_effect, y_1, y_0

    def generate_feature(self, index):
        """
        Parameters
        ----------
        index : int
            represent the index from which distribution should the feature take its value from.
            If only one distribution is provided all features will take from that distribution.
        """
        if len(self.distributions) == 1:
            return self.distributions[0]()
        return self.distributions[index]()

    def create_graphs(self, df, show_graphs, save_graphs):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        try:
            grapher = Grapher(self.directory, show_graphs, save_graphs)

            fn = f'/ground_truth_feat0'
            grapher.scatter_2d(fn, df['feature_0'], df['treatment_effect'],
                               "Feature 0", "Treatment Effect")
            fn = f'/observed_p0f0'
            grapher.scatter_2d(fn, df['proxy_0_for_feature_0'], df['treatment_effect'],
                               "Proxy 0 for feature 0", "Treatment Effect")
            fn = f'/kde_p0f0'
            grapher.kde(fn, df['proxy_0_for_feature_0'])
            fn = f'/kde_f0'
            grapher.kde(fn, df['feature_0'])
            fn = f'/ground_truth_feat1'
            grapher.scatter_2d(fn, df['feature_1'], df['treatment_effect'],
                               "Feature 1", "Treatment Effect")
            fn = f'/ground_truth_feat2'
            grapher.scatter_2d(fn, df['feature_2'], df['treatment_effect'],
                               "Feature 2", "Treatment Effect")
            fn = f'/ground_truth_2d_feat01'
            grapher.scatter_2d_color(fn, df['feature_0'], df['feature_1'], df['treatment_effect'],
                                     "Feature 0", "Feature 1", "Treatment Effect Strength")
        except Exception:
            print(traceback.format_exc())

    def save_data(self, df):
        """
        Parameters
        ----------
        df : pd.DataFrame
            dataframe of generated data
        """
        os.makedirs(self.directory, exist_ok=True)
        filename = f'/generated_data{time.ctime()}.csv'.replace(' ', '_').replace(':', '-')
        self.generated_files['data'].append(filename)
        df.to_csv(self.directory + filename)
